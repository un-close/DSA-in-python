You are given an integer arrayÂ `nums`Â and two integersÂ `minK`Â andÂ `maxK`.

AÂ **fixed-bound subarray**Â ofÂ `nums`Â is a subarray that satisfies the following conditions:

-   TheÂ **minimum**Â value in the subarray is equal toÂ `minK`.
-   TheÂ **maximum**Â value in the subarray is equal toÂ `maxK`.

ReturnÂ _theÂ **number**Â of fixed-bound subarrays_.

AÂ **subarray**Â is aÂ **contiguous**Â part of an array.

**Example 1:**

**Input:** `nums = [1,3,5,2,7,5], minK = 1, maxK = 5`
**Output:** 2
**Explanation:** `The fixed-bound subarrays are [1,3,5] and [1,3,5,2].`

## Summary:
count the no of windows possible within which the given max, min values are maintained

# Intuition:
- 2 pointer approach where the pointers are maintained for the array that qualifies the above conditions
- it's reset for when an element doesn't qualify 

```py
class Solution:

Â  Â  def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:

Â  Â  Â  Â  last_min = last_max = -1

Â  Â  Â  Â  new_start = count = 0

Â  Â  Â  Â  for index, num in enumerate(nums):

Â  Â  Â  Â  Â  Â  if num < minK or num > maxK:

Â  Â  Â  Â  Â  Â  Â  Â  new_start = index + 1 # for the next potential start of an valid sub-array

Â  Â  Â  Â  Â  Â  Â  Â  last_min = last_max = -1 # to skip the current window elements

Â  Â  Â  Â  Â  Â  if num == minK:

Â  Â  Â  Â  Â  Â  Â  Â  last_min = index

Â  Â  Â  Â  Â  Â  if num == maxK:

Â  Â  Â  Â  Â  Â  Â  Â  last_max = index

Â  Â  Â  Â  Â  Â  if -1 not in (last_min, last_max): # to check whether the current window is qualified

Â  Â  Â  Â  Â  Â  Â  Â  count += min(last_min, last_max) - new_start + 1

Â  Â  Â  Â  return count
```

# OR

- lee's solution  [[[Java/C++/Python] Sliding Window with Explanation ðŸ”¥ - Count Subarrays With Fixed Bounds - LeetCode](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/2708099/java-c-python-sliding-window-with-explanation/?orderBy=most_votes)]



